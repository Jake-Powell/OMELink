% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matching_functions.R
\name{match_person_to_data}
\alias{match_person_to_data}
\title{Match a Person's Name to a Data Frame of Individuals}
\usage{
match_person_to_data(
  FN,
  LN,
  data,
  FN_column = "FN",
  LN_column = "LN",
  UPI_column = "UPI",
  max_dist = 2,
  method = "osa",
  show_all_fuzzy = FALSE,
  ...
)
}
\arguments{
\item{FN}{Character string. First name of the person to match.}

\item{LN}{Character string. Last name (surname) of the person to match.}

\item{data}{A data frame containing at least the columns for first name, last name, and UPI.}

\item{FN_column}{Character. Name of the column in `data` that contains first names. Default is `"FN"`.}

\item{LN_column}{Character. Name of the column in `data` that contains last names. Default is `"LN"`.}

\item{UPI_column}{Character. Name of the column in `data` that contains unique identifiers (UPI). Default is `"UPI"`.}

\item{max_dist}{Integer. Maximum string distance allowed for fuzzy matching. Default is `2`.}

\item{method}{Character. String distance method to use. Passed to [stringdist::stringdist()]. Default is `"osa"`.}

\item{show_all_fuzzy}{Logical. If `TRUE`, return all fuzzy matches instead of just the best match. Default is `FALSE`.}

\item{...}{Additional parameters passed to [clean_name()] for name normalization.}
}
\value{
A list with components:
\describe{
  \item{UPI}{The matched UPI(s), or `NA` if no match is found.}
  \item{people}{The matched row(s) from `data`. If no match is found, a single row of `NA`s is returned.}
  \item{message}{Character string describing the match type.}
}
}
\description{
Attempts to match a person's first and last name to a row in a dataset using
exact, swapped, or fuzzy matching techniques.
}
\section{Matching hierarchy}{

Matching is performed in the following order:
\enumerate{
  \item Exact match on first and last name
  \item Exact match with names swapped
  \item Unique single-field exact match
  \item Fuzzy match on both fields
  \item Fuzzy match on either field
}
The first successful match type in this hierarchy is returned.
}

\section{Match message values}{

The returned list contains a `message` element describing the match result.
Possible values are:

\strong{Exact matches}
\itemize{
  \item \code{"EXACT"} – Exact match on first and last name.
  \item \code{"EXACT (Swap)"} – Exact match with first and last names swapped.
}

\strong{Single-field exact matches}
\itemize{
  \item \code{"FN only"} – Unique exact match on first name only.
  \item \code{"LN only"} – Unique exact match on last name only.
  \item \code{"FN only (Swap)"} – Unique exact match using swapped first name.
  \item \code{"LN only (Swap)"} – Unique exact match using swapped last name.
}

\strong{Fuzzy matches (within `max_dist`)}
\itemize{
  \item \code{"FUZZY MATCH (best both FN & LN)"} – Best fuzzy match where both names are within tolerance.
  \item \code{"FUZZY MATCHES (both FN & LN)"} – All fuzzy matches where both names are within tolerance (`show_all_fuzzy = TRUE`).
  \item \code{"FUZZY PARTIAL MATCH (best FN or LN)"} – Best fuzzy match where only one name is within tolerance.
  \item \code{"FUZZY PARTIAL MATCHES (FN or LN)"} – All partial fuzzy matches (`show_all_fuzzy = TRUE`).
}

\strong{No match}
\itemize{
  \item \code{"No match"} – No exact or fuzzy match found.
}
}

\examples{
botanists <- data.frame(
  FN = c("Carl", "José", "Alexander", "Agnes", "  Jane  "),
  LN = c("Linnæus", "Banks", "Humboldt", "Arber", "Coldstream"),
  UPI = c("CL001", "JB002", "AH003", "AA004", "JC005"),
  stringsAsFactors = FALSE
)

# Exact match (accent-insensitive)
match_person_to_data("Jose", "Banks", botanists)

# Swapped names
match_person_to_data("Linnæus", "Carl", botanists)

# No match
match_person_to_data("Greg", "Mendel", botanists)

}
